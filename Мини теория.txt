1 <script async scr=""> - скрипт выполнится тогда, когда загрузится вся страница. При async двух скриптов первый начнет 
выполняться тот, который раньше загрузится.
<script defer scr=""> - скрипт выполнится тогда, когда загрузится вся страница. При defer двух скриптов первый начнет 
выполняться тот, который стоит раньше.

2 скрипт можно загружать при помощи самого javascript
например:
function addScript(src){
  var script = document.createElement('script');
  script.src = src;
  script.async = false; // чтобы гарантировать порядок
  document.head.appendChild(script);
}

3 addScript('1.js'); // загружаться эти скрипты начнут сразу
addScript('2.js'); // выполнятся, как только загрузятся
addScript('3.js'); // но, гарантированно, в порядке 1 -> 2 -> 3

4 "use strict"; - если ваш код JS написан по новому стандарту ES5

5 Function Declaration – функция, объявленная в основном потоке кода. (когда функция традиционно описывается отдельно)
Function Expression - объявление функции в контексте какого-либо выражения, например присваивания (описывается в том же 
месте)

6 isNumeric - норм проверка на число (если там реально число)

7 number.toFixed(num) - округляет число number в точности до num-ого знака (например, var n=5.35; n.toFixed(1) = 5.4)

8 При создании множества объектов одного и того же вида (с одинаковыми полями) интерпретатор выносит описание полей в 
отдельную структуру. А сам объект остаётся в виде непрерывной области памяти с данными.

{name: "Вася", age: 25}				<структура: string name, number age>
{name: "Петя", age: 22}      -------->		Вася 25		
{name: "Маша", age: 19}				Петя 22
...						Маша 19

При добавлении нового объекта такой структуры достаточно хранить значения полей, но не их имена

9 "prop" in obj - проверяет наличие свойства

10 for (key in obj) - перебор всех свойств

11 Переменная, в которую присвоен объект, на самом деле хранит не сами данные, а ключ к сейфу, где они хранятся.

При копировании её, получается что мы сделали копию ключа, но сейф по-прежнему один.

12 Получить случ число от min до max : var rand = min + Math.floor(Math.random() * (max + 1 - min));

13 var arr = names.split(', ') - превращает строку s в массив arr, члены которого формируются по разделителю ', '
   join(part) - делает строку из элементов массива, разделенных part

14. Если мы вызываем функцию с аргументами, а описание функции - без аргументов, то при запуске этой функции аргументы
кладутся в специальный массив (но к нему нельзя применять методы как к массиву) arguments (на самом деле они кладутся туда
 в любом случае, но в первом случае допуск к ним будет только через arguments)

15. Если функция вызвана с меньшим количеством аргументов, чем указано, то отсутствующие аргументы считаются 
равными undefined.

16 В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется 
«глобальный объект» (global object). Доступ к ним можно осуществить через объект window (window.a)

17 Все локальные переменные внутри функции являются свойствами объекта LexicalEnvironment. Если переменная внутри функции
не найдена в LexicalEnvironment, она будет искаться в window

18 Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней:

	function f() {}

	f.test = 5;
	alert( f.test );

Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны 
только внутри функции, они создаются в процессе её выполнения. Это – использование функции «как функции».
А свойство у функции – доступно отовсюду и всегда. Это – использование функции «как объекта».
Если хочется привязать значение к функции, то можно им воспользоваться вместо внешних переменных.

19 Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.

20 [[Scope]] 

21 При объявлении функции new Function () ее [[Scope]]  - window. Следствие – такие функции не могут 
использовать замыкание.

22 Чтобы твои переменные в подключенным файлом .js на конфликтовали с уже существующими (например, одинакокые названия
 переменных), его нужно оборачивать, например:

;(function() {

  // глобальная переменная нашего скрипта
  var message = "Привет";

  // функция для вывода этой переменной
  function showMessage() {
    alert( message );
  }

  // выводим сообщение
  showMessage();

}());

Как видно, функция не имеет имени, то есть она - Function Explesion. Поэтому и заключена в скобочки.

23 В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – 
«ссылка» на него.
При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре.

24. Если в объекте присутствует метод toString, который возвращает примитив, то он используется для преобразования.

          
var user = {

  firstName: 'Василий',

  toString: function() {
    return 'Пользователь ' + this.firstName;
  }
};

alert( user );  // Пользователь Василий

25. Для численного преобразования объекта используется метод valueOf, а если его нет – то toString:           
                                         
var room = {
  number: 777,

  valueOf: function() { return this.number; },
  toString: function() { return this.number; }
};

alert( +room );  // 777, вызвался valueOf

delete room.valueOf; // valueOf удалён

26. Object.defineProperty(obj, prop, descriptor) 
Descriptor:

    value – значение свойства, по умолчанию undefined
    writable – значение свойства можно менять, если true. По умолчанию false.
    configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.
    enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.
    get – функция, которая возвращает значение свойства. По умолчанию undefined.
    set – функция, которая записывает значение свойства. По умолчанию undefined.

Object.defineProperty(user, "name", { value: "Вася", configurable: true, writable: true, enumerable: true });



Пример для Get и Set

var user = {
  firstName: "Вася",
  surname: "Петров"
}

Object.defineProperty(user, "fullName", {

  get: function() {
    return this.firstName + ' ' + this.surname;
  },

  set: function(value) {
      var split = value.split(' ');
      this.firstName = split[0];
      this.surname = split[1];
    }
});


ИЛИ

var user = {
  firstName: "Вася",
  surname: "Петров",

  get fullName() {
    return this.firstName + ' ' + this.surname;
  },

  set fullName(value) {
    var split = value.split(' ');
    this.firstName = split[0];
    this.surname = split[1];
  }
};

alert( user.fullName ); // Вася Петров (из геттера)

user.fullName = "Петя Иванов";
alert( user.firstName ); // Петя  (поставил сеттер)
alert( user.surname ); // Иванов (поставил сеттер)



user.fullName = "Петя Иванов";
alert( user.firstName ); // Петя
alert( user.surname ); // Иванов

27. Методы и свойства, которые не привязаны к конкретному экземпляру объекта, называют «статическими». 
Их записывают прямо в саму функцию-конструктор.

Статический метод также можно использовать для функций, которые вообще не требуют наличия объекта.

28. «Фабричный статический метод» – статический метод, 
который служит для создания новых объектов (поэтому и называется «фабричным»). То есть объект создается в зависимости
от количества переданных параметров

как у Date, например:

    new Date() – создаёт объект с текущей датой,
    new Date(milliseconds) – создаёт дату по количеству миллисекунд milliseconds,
    new Date(year, month, day ...) – создаёт дату по компонентам год, месяц, день…
    new Date(datestring) – читает дату из строки datestring


Например:

function User() {
  this.sayHi = function() {
    alert(this.name)
  };
}

User.createAnonymous = function() {
  var user = new User;
  user.name = 'Аноним';
  return user;
}

User.createFromData = function(userData) {
  var user = new User;
  user.name = userData.name;
  user.age = userData.age;
  return user;
}

// Использование

var guest = User.createAnonymous();
guest.sayHi(); // Аноним

var knownUser = User.createFromData({
  name: 'Вася',
  age: 25
});
knownUser.sayHi(); // Вася

29. Синтаксис метода call:

func.call(context, arg1, arg2, ...)
При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть».

Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).

При помощи call можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого.

Это называется «одалживание метода» (на англ. method borrowing).

Например: 

function printArgs() {
  var join = [].join; // скопируем ссылку на функцию в переменную

  // вызовем join с this=arguments,
  // этот вызов эквивалентен arguments.join(':') из примера выше
  var argStr = join.call(arguments, ':');

  alert( argStr ); // сработает и выведет 1:2:3
}

printArgs(1, 2, 3);

30.  Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply.

Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.

func.call(context, arg1, arg2);
// идентичен вызову
func.apply(context, [arg1, arg2]);

31. Пример потери контекста:

var user = {
  firstName: "Вася",
  sayHi: function() {
    alert( this.firstName );
  }
};

setTimeout(user.sayHi, 1000); // undefined (не Вася!)  

Это потому, что setTimeout получил функцию user.sayHi, но не её контекст

Использование привязки контекста через вспомогательную функцию bind:

function bind(func, context) {
  return function() { 
    return func.apply(context, arguments);
  };
}

function f() {
  alert( this );
}

var g = bind(f, "Context");
g(); // Context


Но в JS есть встроенный bind:

var wrapper = func.bind(context[, arg1, arg2...])

32. Карринг (currying) или каррирование – термин функционального программирования, который означает создание 
новой функции путём фиксирования аргументов существующей.

33. Использование специального свойства [[Class]] через метод toString:

var toString = {}.toString;

var arr = [1, 2];
alert( toString.call(arr) ); // [object Array]

var date = new Date;
alert( toString.call(date) ); // [object Date]

var user = { name: "Вася" };
alert( toString.call(user) ); // [object Object]

Для получения [[Class]] нужна именно внутренняя реализация toString стандартного объекта Object, другая не подойдёт.

34. Оператор instanceof позволяет проверить, создан ли объект данной функцией, 
причём работает для любых функций – как встроенных, так и наших.

35. Для проверки типа на массив есть специальный метод: Array.isArray(arr). 
Он возвращает true только если arr – массив

36.